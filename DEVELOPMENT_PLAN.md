# План разработки: Бот «Исправитель»

Формат — короткие таски с чек-боксами для контроля качества кода и тестирования. 
Отмечайте выполненные задачи, проставляя `[x]` вместо `[ ]`.

Легенда отметок качества (каждую задачу закрываем, когда выполнены все подпункты):
- [ ] Код реализован
- [ ] Тесты (unit/integration) добавлены и проходят локально
- [ ] Линтер/форматтер (ruff) проходит
- [ ] Документация/README/PRP обновлены

## Итерация 0 — Подготовка окружения
- [ ] Проверить Python 3.11+, `uv`, `ruff` в окружении
- [ ] Уточнить и зафиксировать формат входного Excel (обязательные поля)
- [ ] Добавить пример `.env.example`

## Итерация 1 — Конфигурация и фичефлаги
- [x] Вынести конфиги в `.env` (`CATALOG_API_URL`, `CATALOG_API_KEY`, `CATALOG_ID`, `USE_MOCKS`, `MOCK_PROFILE`, `SEED`)
- [x] Добавить модуль `config.py` (загрузка env, валидация)
- [x] Тесты: загрузка конфигов, дефолты, ошибки
- [x] Ruff/Docs обновлены (README: «Как запускать с моками»)

## Итерация 2 — Слой абстракций и DI
- [x] Добавить `services.py` с фабриками клиентов (реальный/мок) по флагам
- [x] Применить фабрики в `main.py` и `ui_streamlit.py`
- [x] Тесты: подмена клиентов, профили mock
- [x] Ruff/Docs

## Итерация 3 — Мок catalogApp
- [x] `mocks/catalog_api_mock.py`: `search`, `create`, `update` (детерминированные ответы по `MOCK_PROFILE`)
- [x] Контракты данных согласованы с PRP
- [x] Тесты сценариев: found/missing/conflict/update
- [ ] Ruff/Docs

## Итерация 4 — Мок LCSC
- [x] `mocks/lcsc_mock.py`: `search(partnumber)` → список кандидатов
- [x] Профили: happy/missing/conflict/errorrate10
- [x] Тесты: fallback на LCSC при отсутствии каталога, парсинг полей
- [ ] Ruff/Docs

## Итерация 5 — Мок LLM
- [x] `mocks/llm_mock.py`: `normalize()` и `classify()` с `confidence`
- [x] Порог `confidence` конфигурируемый (`CONFIDENCE_THRESHOLD` в `config.py`)
- [x] Тесты: нормализация и классификация (детерминизм, диапазон `confidence`)
- [ ] Ruff/Docs

## Итерация 6 — Обработка в `main.py`
- [x] Поток (скелет на моках): search → (если нет) LCSC → LLM → решение (create/update/skip/conflict)
- [x] Обработка ошибок построчно (строка с ошибкой не блокирует партию)
- [x] Тесты интеграционные (mock-сценарии) на поток `main.py`
- [ ] Ruff/Docs

## Итерация 7 — UI (`ui_streamlit.py`)
- [x] Использовать фабрики клиентов и общий поток обработки
- [x] Кнопка запуска, прогресс/статусы, скачивание отчета
- [x] Тесты (smoke) или e2e c заглушкой
- [ ] Ruff/Docs (скриншоты опционально)

## Итерация 8 — Отчетность
- [x] Расширить `reporter.py`: поля `found_in_catalog`, `action`, `reason`, `confidence`, `attrs_norm`, `errors`
- [x] Валидация и сериализация `attrs_norm (json)`
- [x] Тесты: корректность колонок/значений, создание файла
- [x] Ruff/Docs (описание полей отчета)

## Итерация 9 — Валидация входных данных
- [x] Проверка обязательных полей, типов, дубликатов `partnumber`
- [x] Протокол ошибок/предупреждений
- [x] Тесты: невалидные строки, частично заполненные поля
- [x] Ruff/Docs

## Итерация 10 — Логирование и наблюдаемость
- [x] Единый логгер (уровни INFO/WARN/ERROR), префиксы по шагам
- [x] Логи в файл + консоль, минимальная корреляция по run-id
- [x] Тесты: отсутствие исключений при логировании, формат сообщений
- [x] Ruff/Docs

## Итерация 11 — Планировщик/Агент
- [x] Уточнить расписание, путь к входному файлу
- [x] Безопасный запуск `agent.py` (schedule), контроль ошибок
- [x] Тесты: имитация выполнения job, мок `subprocess`
- [x] Ruff/Docs

## Итерация 12 — Контейнеризация
- [x] Разделить docker-compose на `worker` (cron/agent) и `ui` (Streamlit)
- [x] Описать переменные окружения для обоих сервисов
- [x] Тесты (smoke): сборка, запуск, healthcheck (опц.)
- [x] Ruff/Docs

## Итерация 13 — Тестовое покрытие и устойчивость
- [x] Добавить негативные кейсы (таймауты/ошибки в моках)
- [x] Ретраи/таймауты в «реальных» клиентах (интерфейс подготовлен в `main.py` ретраями; для real-клиентов — следующий шаг)
- [x] Метрики базовые (подсчет статусов в отчете — лист `metrics`)
- [x] Ruff/Docs

## Итерация 14 — CI/CD (минимум)
- [ ] GitHub Actions: ruff + pytest (кэш зависимостей)
- [x] Бейдж в README
- [ ] Тесты: успех пайплайна на PR
- [x] Docs (вкладка «Разработка»)

## Итерация 15 — Документация
- [ ] Обновить `README.md`: запуск с моками, профили, примеры
- [ ] Обновить `PRP.md` при изменении контрактов
- [ ] Добавить «Troubleshooting» и «FAQ»
- [ ] Проверка согласованности диаграмм (`sequence_diagram.puml`)

---

### Контрольные критерии завершения (Definition of Done) для каждой итерации
- [ ] Все таски итерации закрыты (чек-боксы отмечены)
- [ ] Тесты проходят локально и в CI (когда появится)
- [ ] Линтер/форматтер без ошибок
- [ ] Документация обновлена
- [ ] Артефакты (отчеты/скриншоты/лог-файлы) приложены при необходимости

---

### Статус на 2025-08-28
- [x] Реализованы ретраи и таймауты в реальном `CatalogAPI` с экспоненциальным бэкоффом и джиттером; параметры проброшены через `config.py` и `services.py`.
- [x] Обновлены тесты (`test_catalog_api_real.py`, `test_services.py`, `test_config.py`) — покрытие бэкоффа, проверка DI и парсинга конфигурации.
- [x] Обновлён `README.md` (новые переменные окружения `CATALOG_BACKOFF_*`, `BACKOFF_*`).
- [x] Все тесты проходят локально (`pytest -q`).

### Статус на 2025-08-29
- [x] Реализованы реальные клиенты:
  - LCSC: HTTP-клиент `lcsc_client.py` (по `LCSC_API_URL`, `LCSC_API_KEY`, таймауты/ретраи/бэкофф из `config.py`).
  - LLM: REST-клиент `llm_client.py` (`/normalize`, `/classify`) с таймаутами/ретраями/бэкоффом.
- [x] Расширен `services.py`: фабрики возвращают моки или реальные клиенты по `USE_MOCKS`.
- [x] Расширен `catalog_api.py`: добавлены `create_product`, `update_product` с ретраями и бэкоффом.
- [x] Обновлён `main.py`: при `update` учитываются `brand`, `external_id`, `gn`, `vn`; при `create` прокидываются `external_id`, `gn`, `vn` и нормализованные атрибуты.
- [x] Обновлён `config.py`: добавлены параметры `LCSC_*` и `LLM_*`.
- [x] Обновлён `README.md`: документированы реальные клиенты и переменные окружения.

Итого: ограничения по отсутствию реальных клиентов LCSC/LLM и упрощённых сценариев обновления сняты — проект готов к тестированию в реальном окружении бизнеса (при наличии валидных URL/API-ключей).
